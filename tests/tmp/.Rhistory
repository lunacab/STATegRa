error = function(e){
tempRes <- matrix(NA, dim(dataMapping)[1], dim(dataMapping)[2] - 1);
rownames(tempRes) <- rownames(dataMapping);
colnames(tempRes) <- colnames(dataMapping)[1:(dim(dataMapping)[2] - 1)];
return(tempRes)
}
)
}
statsPerm <- foreach(i = 1:numPerms) %do% {
#tryCatch({executePermutation(...)},
tryCatch({executePermutation()},
error = function(e){
tempRes <- matrix(NA, dim(dataMapping)[1], dim(dataMapping)[2] - 1);
rownames(tempRes) <- rownames(dataMapping);
colnames(tempRes) <- colnames(dataMapping)[1:(dim(dataMapping)[2] - 1)];
return(tempRes)
}
)
}
statsPerm <- c(list(stats0), statsPerm)
statsPerm <- array(unlist(statsPerm),
dim = c(nrow(statsPerm[[1]]), ncol(statsPerm[[1]]), length(statsPerm)),
dimnames = list(rownames(statsPerm[[1]]),
colnames(statsPerm[[1]]),
1:length(statsPerm)))
if(verbose){
message("Compute pseudo p-values based on NULL distributions...")
}
pvaluesPerm <- statisticsToPvalues(statsPerm)
pvaluesPerm <- aperm(pvaluesPerm, c(2, 3, 1)) # magic numbers!
pvalues0 <- matrix(pvaluesPerm[ , , 1],
nrow = numMeasurements,
ncol = numDataMatrices,
dimnames = dimnames(pvaluesPerm)[1:2]);
if(verbose){
message("NPC p-values calculation...")
}
allCombinations
combinations <- list();
for(i in 2:numDataMatrices){
combinations <- c(combinations, combn(1:numDataMatrices, i, simplify = FALSE));
}
numCombinations <- length(combinations);
dataMappings <- vector('list', numCombinations);
pvaluesNPC <- vector('list', numCombinations);
j = 1
statsNPC <- array(dim = c(numMeasurements, numCombMethods, numPerms + 1),
dimnames = list(measurements, combMethods, dimnames(pvaluesPerm)[[3]]));
for(i in 1:numCombMethods){
statsNPC[ , i, ] <-  apply(pvaluesPerm[ , combinations[[j]], ], 3, combiningPvalues, method = combMethods[i], dataWeights = dataWeights);
}
for(j in 1:numCombinations){
#initializing
statsNPC <- array(dim = c(numMeasurements, numCombMethods, numPerms + 1),
dimnames = list(measurements, combMethods, dimnames(pvaluesPerm)[[3]]));
#is parallel available?
if(parallelAvailable){
#creating the cluster
cl <- parallel::makeCluster(numCores)
#registering the cluster
doSNOW::registerDoSNOW(cl)
#combining the pvalues. Here we choose which data matrice to combine
for(i in 1:numCombMethods){
statsNPC[ , i, ] <- foreach(k = 1:dim(pvaluesPerm)[3], .combine = 'cbind') %dopar% {
source('../../omicsNPC/code/stategra/R/STATegRa_omicsNPC_internal.R');
source('../../omicsNPC/code/stategra/R/STATegRa_omicsNPC_ancillaryFunctions.R');
combiningPvalues(as.matrix(pvaluesPerm[ , combinations[[j]], k]), method = combMethods[i], dataWeights = dataWeights);
}
}
#closing the cluster
stopCluster(cl)
}else{
#combining the pvalues. Here we choose which data matrice to combine
for(i in 1:numCombMethods){
statsNPC[ , i, ] <-  apply(pvaluesPerm[ , combinations[[j]], ], 3, combiningPvalues, method = combMethods[i], dataWeights = dataWeights);
}
}
#let's ensure that all statistics are larger than 0
#this does not affect the computation of the pvalues
finiteStats <- !is.infinite(statsNPC);
minStats <- min(statsNPC[finiteStats], na.rm = TRUE);
maxStats <- max(statsNPC[finiteStats], na.rm = TRUE);
statsNPC[!finiteStats & sign(statsNPC) < 0] <- minStats - 1;
statsNPC[!finiteStats & sign(statsNPC) > 0] <- maxStats + 1;
minStats <- min(statsNPC, na.rm = TRUE);
statsNPC <- statsNPC - min(statsNPC) + 1
#computing the NPC p-values
pvaluesNPCTemp <- statisticsToPvalues(statsNPC);
pvaluesNPCTemp <- aperm(pvaluesNPCTemp, c(2, 3, 1)) # magic numbers!
#creating the data mapping for the combination at hand
dataMappingTmp <- dataMapping[, combinations[[j]]];
toKeep <- !duplicated(dataMappingTmp) & !apply(dataMappingTmp, 1, function(x){all(is.na(x))})
dataMappingTmp <- cbind(dataMappingTmp[toKeep, ], dataMapping[toKeep, ncol(dataMapping)]) #adding the reference
rownames(dataMappingTmp) <- apply(dataMappingTmp, 1, function(x){paste(x, collapse = ':')});
#keeping only the relevant pvalues
if(!returnPermPvalues){
pvaluesNPC[[j]] <- matrix(pvaluesNPCTemp[toKeep, , 1],
nrow = sum(toKeep),
ncol = numCombMethods,
dimnames = list(dimnames(pvaluesNPCTemp)[[1]][toKeep], dimnames(pvaluesNPCTemp)[[2]]))
rownames(pvaluesNPC[[j]]) <- rownames(dataMappingTmp);
}else{
pvaluesNPC[[j]] <- pvaluesNPCTemp[toKeep, , ];
dimnames(pvaluesNPC[[j]])[[1]] <- rownames(dataMappingTmp);
}
#storing and naming the results
dataMappings[[j]] <- dataMappingTmp;
names(pvaluesNPC)[j] <- paste(datasetsNames[combinations[[j]]], collapse = '_');
names(dataMappings)[j] <- names(pvaluesNPC)[j];
#adding data mapping to pvaluesNPC
pvaluesNPC[[j]] <- cbind(dataMappings[[j]], pvaluesNPC[[j]])
rownames(pvaluesNPC[[j]]) <- NULL;
}
pvaluesNPC[[j]]
dataMappings <- vector('list', numCombinations);
pvaluesNPC <- vector('list', numCombinations);
pvaluesNPC[[j]]
for(j in 1:numCombinations){
#initializing
statsNPC <- array(dim = c(numMeasurements, numCombMethods, numPerms + 1),
dimnames = list(measurements, combMethods, dimnames(pvaluesPerm)[[3]]));
#is parallel available?
if(parallelAvailable){
#creating the cluster
cl <- parallel::makeCluster(numCores)
#registering the cluster
doSNOW::registerDoSNOW(cl)
#combining the pvalues. Here we choose which data matrice to combine
for(i in 1:numCombMethods){
statsNPC[ , i, ] <- foreach(k = 1:dim(pvaluesPerm)[3], .combine = 'cbind') %dopar% {
source('../../omicsNPC/code/stategra/R/STATegRa_omicsNPC_internal.R');
source('../../omicsNPC/code/stategra/R/STATegRa_omicsNPC_ancillaryFunctions.R');
combiningPvalues(as.matrix(pvaluesPerm[ , combinations[[j]], k]), method = combMethods[i], dataWeights = dataWeights);
}
}
#closing the cluster
stopCluster(cl)
}else{
#combining the pvalues. Here we choose which data matrice to combine
for(i in 1:numCombMethods){
statsNPC[ , i, ] <-  apply(pvaluesPerm[ , combinations[[j]], ], 3, combiningPvalues, method = combMethods[i], dataWeights = dataWeights);
}
}
#let's ensure that all statistics are larger than 0
#this does not affect the computation of the pvalues
finiteStats <- !is.infinite(statsNPC);
minStats <- min(statsNPC[finiteStats], na.rm = TRUE);
maxStats <- max(statsNPC[finiteStats], na.rm = TRUE);
statsNPC[!finiteStats & sign(statsNPC) < 0] <- minStats - 1;
statsNPC[!finiteStats & sign(statsNPC) > 0] <- maxStats + 1;
minStats <- min(statsNPC, na.rm = TRUE);
statsNPC <- statsNPC - min(statsNPC) + 1
#computing the NPC p-values
pvaluesNPCTemp <- statisticsToPvalues(statsNPC);
pvaluesNPCTemp <- aperm(pvaluesNPCTemp, c(2, 3, 1)) # magic numbers!
#creating the data mapping for the combination at hand
dataMappingTmp <- dataMapping[, combinations[[j]]];
toKeep <- !duplicated(dataMappingTmp) & !apply(dataMappingTmp, 1, function(x){all(is.na(x))})
dataMappingTmp <- cbind(dataMappingTmp[toKeep, ], dataMapping[toKeep, ncol(dataMapping)]) #adding the reference
rownames(dataMappingTmp) <- apply(dataMappingTmp, 1, function(x){paste(x, collapse = ':')});
#keeping only the relevant pvalues
if(!returnPermPvalues){
pvaluesNPC[[j]] <- matrix(pvaluesNPCTemp[toKeep, , 1],
nrow = sum(toKeep),
ncol = numCombMethods,
dimnames = list(dimnames(pvaluesNPCTemp)[[1]][toKeep], dimnames(pvaluesNPCTemp)[[2]]))
rownames(pvaluesNPC[[j]]) <- rownames(dataMappingTmp);
}else{
pvaluesNPC[[j]] <- pvaluesNPCTemp[toKeep, , ];
dimnames(pvaluesNPC[[j]])[[1]] <- rownames(dataMappingTmp);
}
#storing and naming the results
dataMappings[[j]] <- dataMappingTmp;
names(pvaluesNPC)[j] <- paste(datasetsNames[combinations[[j]]], collapse = '_');
names(dataMappings)[j] <- names(pvaluesNPC)[j];
#adding data mapping to pvaluesNPC
pvaluesNPC[[j]] <- cbind(dataMappings[[j]], pvaluesNPC[[j]])
rownames(pvaluesNPC[[j]]) <- NULL;
}
for(i in 1:length(dataMatrices)){
P.Value.Perm <- pvalues0[, i]
adj.P.Val.Perm <- p.adjust(P.Value.Perm, method = 'fdr')
results0[[i]] <- cbind(results0[[i]]$results, P.Value.Perm, adj.P.Val.Perm)
}
pvaluesNPC <- cbind(dataMapping[, 1:length(dataMatrices)], pvaluesNPC)
#### Script for testing the omicsNPC function ####
#### Set up ####
#memory, library and sourcing
rm(list = ls())
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
library(foreach)
library(data.table)
#control panel
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 1;
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
print(results)
rm(list = ls())
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
library(foreach)
library(data.table)
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 1;
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
print(results)
phenotypeData <- as.data.frame(phenotypeData)
phenotypeData[, 'outcome'] <- rep(letters[1:3], 10)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
print(results)
phenotypeData[, 'outcome'] <- Surv(time = runif(30),
event = sample(0:1, size = 30, replace = TRUE))
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
print(results)
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataset3 <- matrix(rnorm(100*30), 100, 30)
rownames(dataset3) <- paste('m', 1:100, sep = '_')
colnames(dataset3) <- paste('sample', 1:30, sep = '_')
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2), rownames(dataset3))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2', 'dataset3')
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = FALSE, numPerms = numPerms, numCores = 1)
print(results)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = 1)
print(results)
#### Script for testing the omicsNPC function ####
#### Set up ####
#memory, library and sourcing
rm(list = ls())
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
library(foreach)
library(data.table)
#control panel
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 1;
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
print(results)
#### Multi-class outcome, two datasets ####
#changing phenotype
phenotypeData <- as.data.frame(phenotypeData)
phenotypeData[, 'outcome'] <- rep(letters[1:3], 10)
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
print(results)
#### Survival outcome, two datasets ####
#changing phenotype
phenotypeData[, 'outcome'] <- Surv(time = runif(30),
event = sample(0:1, size = 30, replace = TRUE))
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
print(results)
#### Binary outcome, three datasets ####
#changing phenotype
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#additional dataset
dataset3 <- matrix(rnorm(100*30), 100, 30)
rownames(dataset3) <- paste('m', 1:100, sep = '_')
colnames(dataset3) <- paste('sample', 1:30, sep = '_')
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2), rownames(dataset3))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2', 'dataset3')
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = FALSE, numPerms = numPerms, numCores = 1)
print(results)
#### Binary outcome, three datasets, all combinations ####
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = 1)
print(results)
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
library(foreach)
library(data.table)
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 1;
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
source('../../R/STATegRa_omicsNPC.R')
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC.R')
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
set.seed(12345)
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
results$dataset1
#### Script for testing the omicsPC function ####
#### Set up ####
#memory, library and sourcing
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
#control panel
set.seed(12345)
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
#omicsPC
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
phenotypeData[, 'outcome'] <- Surv(time = runif(30),
event = sample(0:1, size = 30, replace = TRUE))
phenotypeData <- as.data.frame(phenotypeData)
phenotypeData[, 'outcome'] <- rep(letters[1:3], 10)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
phenotypeData[, 'outcome'] <- Surv(time = runif(30),
event = sample(0:1, size = 30, replace = TRUE))
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = 1)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataset3 <- matrix(rnorm(100*30), 100, 30)
rownames(dataset3) <- paste('m', 1:100, sep = '_')
colnames(dataset3) <- paste('sample', 1:30, sep = '_')
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2), rownames(dataset3))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2', 'dataset3')
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData)
print(results)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE)
print(results)
source('D:/Dropbox (Personal)/inprogress/TwoPagesBionformatics/STATegRa/tests/tmp/testOmicsPC_update.R')
#### Script for testing the omicsPC function ####
#### Set up ####
#memory, library and sourcing
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
#control panel
set.seed(12345)
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
#omicsPC
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
source('D:/Dropbox (Personal)/inprogress/TwoPagesBionformatics/STATegRa/tests/tmp/testOmicsPC_update.R')
source('D:/Dropbox (Personal)/inprogress/TwoPagesBionformatics/STATegRa/tests/tmp/testOmicsPC_update.R')
