# define some simulated equivalences
dataset[, 15] <- dataset[, 10] + rnorm(1000, 0, 2)
dataset[, 150] <- dataset[, 100] + rnorm(1000, 0, 2)
dataset[, 130] <- dataset[, 100] + rnorm(1000, 0, 2)
# run the SES algorithm
sesObject <- SES(target , dataset, max_k = 5, threshold = 0.05, test = "testIndFisher",
hash = TRUE, hashObject = NULL);
# print summary of the SES output
summary(sesObject);
SES
MXM:::InternalSES
sesObject@pvalues
summary(sesObject@pvalues)
library(devtools)
session_info()
1 - pchisq(q = 14.21, df = 10, log.p = TRUE)
pchisq(q = 14.21, df = 10, log.p = TRUE)
pchisq(q = 14.21, df = 11, log.p = TRUE)
pchisq(q = 14.21, df = 100, log.p = TRUE)
pchisq(q = 14.21, df = 30, log.p = TRUE)
pchisq(q = 14.21, df = 40, log.p = TRUE)
pchisq(q = 14.21, df = 45, log.p = TRUE)
pchisq(q = 14.21, df = 42, log.p = TRUE)
pchisq(q = 14.21, df = 43, log.p = TRUE)
exp(-11.025530)
exp(-exp(-0.929+0.708*ln(16)))
exp(-exp(-0.929+0.708*log(16)))
ss = c(5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000)
ss <- c(5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000)
nSs <- length(ss)
aveDiff <- 0.001
pvalues <- c()
for(i in 1:nSs){
sample1 <-rnorm(ss[i])
sample2 <-rnorm(ss[i]) + aveDiff
pvalues[i] <- t.test(sample1, sample2)$p.value
}
pvalues
ss <- c(5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000)
nSs <- length(ss)
aveDiff <- 0.01
pvalues <- c()
for(i in 1:nSs){
sample1 <-rnorm(ss[i])
sample2 <-rnorm(ss[i]) + aveDiff
pvalues[i] <- t.test(sample1, sample2)$p.value
}
pvalues
ss <- c(5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000)
nSs <- length(ss)
aveDiff <- 0.001
pvalues <- c()
for(i in 1:nSs){
sample1 <-rnorm(ss[i])
sample2 <-rnorm(ss[i]) + aveDiff
pvalues[i] <- t.test(sample1, sample2)$p.value
}
pvalues
ss <- c(5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000)
nSs <- length(ss)
aveDiff <- 0.01
pvalues <- c()
for(i in 1:nSs){
sample1 <-rnorm(ss[i])
sample2 <-rnorm(ss[i]) + aveDiff
pvalues[i] <- t.test(sample1, sample2)$p.value
}
pvalues
mean(sample1)
sd(sample1)
toPlot <- data.frame(sampleSize = ss, pvalue = pvalues)
p <- ggplot(data = toPlot, mapping = aes(x = samplSize, y = pvalue)) +
geom_point()
library(ggplot2)
toPlot <- data.frame(sampleSize = log10(ss), pvalue = -log10(pvalues))
p <- ggplot(data = toPlot, mapping = aes(x = samplSize, y = pvalue)) +
geom_point()
plot(p)
p <- ggplot(data = toPlot, mapping = aes(x = sampleSize, y = pvalue)) +
geom_point()
plot(p)
ss <- c(5, 10, 50, 100, 500, 1000,
5000, 10000, 50000, 100000,
500000, 1000000,
5000000, 10000000)
nSs <- length(ss)
aveDiff <- 0.01
pvalues <- c()
for(i in 1:nSs){
sample1 <-rnorm(ss[i])
sample2 <-rnorm(ss[i]) + aveDiff
pvalues[i] <- t.test(sample1, sample2)$p.value
}
pvalues
library(ggplot2)
toPlot <- data.frame(sampleSize = log10(ss), pvalue = -log10(pvalues))
p <- ggplot(data = toPlot, mapping = aes(x = sampleSize, y = pvalue)) +
geom_point()
plot(p)
p <- ggplot(data = toPlot, mapping = aes(x = sampleSize, y = pvalue)) +
geom_point() +
xlab('log10 sample size') +
ylab('-log10 pvalue') +
theme_bw()
plot(p)
p <- ggplot(data = toPlot, mapping = aes(x = sampleSize, y = pvalue)) +
geom_point() +
xlab('log10 sample size') +
ylab('-log10 pvalue') +
theme_bw() +
scale_y_continuous(breaks = 1:7,
labels = c('10', '10^2',
'10^3', '10^4',
'10^5', '10^6', '10^7'))
plot(p)
library(ggplot2)
toPlot <- data.frame(sampleSize = log10(ss), pvalue = -log10(pvalues))
p <- ggplot(data = toPlot, mapping = aes(x = sampleSize, y = pvalue)) +
geom_point() +
xlab('log10 sample size') +
ylab('-log10 pvalue') +
theme_bw() +
scale_x_continuous(breaks = 1:7,
labels = c('10', '10^2',
'10^3', '10^4',
'10^5', '10^6', '10^7'))
plot(p)
ss <- c(5, 10, 50, 100, 500, 1000,
5000, 10000, 50000, 100000,
500000, 1000000)
nSs <- length(ss)
aveDiff <- 0.05
pvalues <- c()
for(i in 1:nSs){
sample1 <-rnorm(ss[i])
sample2 <-rnorm(ss[i]) + aveDiff
pvalues[i] <- t.test(sample1, sample2)$p.value
}
pvalues
library(ggplot2)
toPlot <- data.frame(sampleSize = log10(ss), pvalue = -log10(pvalues))
p <- ggplot(data = toPlot, mapping = aes(x = sampleSize, y = pvalue)) +
geom_point() +
xlab('log10 sample size') +
ylab('-log10 pvalue') +
theme_bw() +
scale_x_continuous(breaks = 1:7,
labels = c('10', '10^2',
'10^3', '10^4',
'10^5', '10^6', '10^7'))
plot(p)
ss <- c(5, 10, 50, 100, 500, 1000,
5000, 10000, 50000, 100000,
500000, 1000000)
nSs <- length(ss)
aveDiff <- 0.01
pvalues <- c()
for(i in 1:nSs){
sample1 <-rnorm(ss[i])
sample2 <-rnorm(ss[i]) + aveDiff
pvalues[i] <- t.test(sample1, sample2)$p.value
}
pvalues
library(ggplot2)
toPlot <- data.frame(sampleSize = log10(ss), pvalue = -log10(pvalues))
p <- ggplot(data = toPlot, mapping = aes(x = sampleSize, y = pvalue)) +
geom_point() +
xlab('log10 sample size') +
ylab('-log10 pvalue') +
theme_bw() +
scale_x_continuous(breaks = 1:6,
labels = c('10', '10^2',
'10^3', '10^4',
'10^5', '10^6'))
plot(p)
png(filename = 'pvalues.png', width = 1500, height = 1200, res = 300)
plot(p)
dev.off()
# Number of Genes
numGenes <- 5000
# Number of Permutations
numPerm <- 1001
# NULL statistics generation
statisticsNULL <- matrix(data = rnorm(n = numGenes * numPerm, mean = 10, sd = 2),
nrow = numGenes, ncol = numPerm)
require(parallel)
FDR_calculation <- function(statistics){
# statistics: matrix
# columns: statistics, first column initial statistics,
#          other columns statistics created during permutations
# rows: genes
statistics <- abs(statistics)
num_perm <- ncol(statistics) - 1
init_stats <- statistics[,1]
perm_stats <- statistics[,2: (num_perm + 1)]
q <- median(perm_stats)
pi0 <- (2*sum(init_stats <= q))/ length(init_stats)
fdr <- function(threshold){
V <- sum(perm_stats > threshold)/num_perm
R <- sum(init_stats > threshold)
FDR <- pi0*V/R
return(FDR)
}
FDR <- sapply(X = init_stats, FUN = fdr)
return(FDR)
}
FDR_calculation.parallel <- function(statistics, ncores){
# statistics: matrix
# columns: statistics, first column initial statistics,
#          other columns statistics created during permutations
# rows: genes
statistics <- abs(statistics)
num_perm <- ncol(statistics) - 1
init_stats <- statistics[,1]
perm_stats <- statistics[,2: (num_perm + 1)]
q <- median(perm_stats)
pi0 <- (2*sum(init_stats <= q))/ length(init_stats)
fdr <- function(threshold, init_stats, perm_stats, num_perm){
V <- sum(perm_stats > threshold)/num_perm
R <- sum(init_stats > threshold)
FDR <- pi0*V/R
return(FDR)
}
FDR <- mclapply(X = init_stats, FUN = fdr, init_stats = init_stats,
perm_stats = perm_stats, num_perm = num_perm,
mc.cores = ncores)
return(unlist(FDR))
}
numGenes <- 5000
numPerm <- 1001
statisticsNULL <- matrix(data = rnorm(n = numGenes * numPerm, mean = 10, sd = 2),
nrow = numGenes, ncol = numPerm)
system.time(test <- FDR_calculation(statistics = statisticsNULL))
summary(test.parallel)
system.time(test.parallel <- FDR_calculation.parallel(statistics = statisticsNULL))
summary(test)
library(bnlearn)
e
e <- empty.graph()
e <- empty.graph(1)
e <- empty.graph('1')
e
dag
dag <- matrix(rnorm(25) >1, 5, 5)
amat(e) <- dag
e <- empty.graph(letters[1:5])
amat(e) <- dag
dag <- matrix(rnorm(25) >1, 5, 5)
amat(e) <- dag
e
b <- rbn(e)
?rbn
2^12
getwd()
(98*27)/(1036*51)
log2(-1)
e^(-1)
2^(-1)
testedSamples <- 78
positiveSamples <- 49
sampleBinary <- rep(0, testedSamples)
sampleBinary[sample(1:testedSamples, positiveSamples)] <- 1
r(list = ls())
set.seed(12345)
testedSamples <- 78
positiveSamples <- 49
sampleBinary <- rep(0, testedSamples)
rm(list = ls())
set.seed(12345)
testedSamples <- 78
positiveSamples <- 49
sampleBinary <- rep(0, testedSamples)
sampleBinary[sample(1:testedSamples, positiveSamples)] <- 1
sampleBinary
sum(sampleBinary)
percs
perc
perc <- sum(sampleBinary) / length(sampleBinary)
perc
rm(list = ls())
set.seed(12345)
testedSamples <- 78
positiveSamples <- 49
nboots <- 10000
sampleBinary <- rep(0, testedSamples)
sampleBinary[sample(1:testedSamples, positiveSamples)] <- 1
perc <- sum(sampleBinary) / length(sampleBinary)
percs <- c()
for(i in 1:nboots){
newSampleBinary <- sampleBinary[sample(1:testedSamples, testedSamples, replace = TRUE)]
percs[i] <- sum(newSampleBinary) / length(newSampleBinary)
}
quantile(percs, c(0.025, 0.975))
install.packages('mbmdt')
install.packages('mbmdr')
install.packages('mbmdr')
library(mbmdr)
mbmdr
library(mbmdr)
devtools::install_github("mensxmachina/BioDataome")
library(d3heatmap)
devtools::install_github("mensxmachina/BioDataome")
library(BioDataome)
GSE10026<-curateGSE("GSE10026","GPL570",getwd())
a <- list
a <- list()
a
dim(a)
length(a)
a <- data.frame()
dim(a)
length(a)
a <- matrix()
length(a)
dim(a)
a
is.null(a)
is.null(dim(a))
library(pROC)
setwd('D:\\Dropbox (Personal)\\inprogress\\TwoPagesBionformatics\\STATegRa\\tests\\tmp')
#### Script for testing the omicsNPC function ####
#### Set up ####
#memory, library and sourcing
rm(list = ls())
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsPC_internal.R')
library(foreach)
library(data.table)
#control panel
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 3;
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#one data matrix is actually differentially expressed
dataset1[ , 16:20] <- dataset1[ , 16:20] + 3 * matrix(runif(100 * 5), 100, 5)
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
#### Script for testing the omicsNPC function ####
#### Set up ####
#memory, library and sourcing
rm(list = ls())
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsPC_internal.R')
library(foreach)
library(data.table)
#control panel
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 3;
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#one data matrix is actually differentially expressed
dataset1[ , 16:20] <- dataset1[ , 16:20] + 3 * matrix(runif(100 * 5), 100, 5)
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
resultsNPC <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores, returnPermPvalues = TRUE)
dim(resultsNPC$pvaluesPerm)
dimnames(resultsNPC$pvaluesPerm)
dimnames(resultsNPC$pvaluesPerm[, 1, ])
class(resultsNPC$pvaluesPerm)
class(resultsNPC$pvaluesPerm[, 1, ])
resultsNPC$pvaluesPerm[, 1, ]
resultsNPC$dataset1
resultsNPC$dataset2
resultsNPC$pvaluesNPC
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#one data matrix is actually differentially expressed
dataset1[ , 16:20] <- dataset1[ , 16:20] + 3 * matrix(runif(100 * 5), 100, 5)
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
#omicsNPC
resultsNPC <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(resultsNPC)
#omicsPC
resultsPC <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2),
dataMapping = dataMapping, phenotypeData = phenotypeData)
print(resultsPC)
#computing fisher p-values from scratch
p1 <- resultsPC$dataset1[dataMapping$dataset1, 'P.Value']
p2 <- resultsPC$dataset2[dataMapping$dataset2, 'P.Value']
x2 <- -2 * (log(p1) + log(p2))
fisherPvalue <- pchisq(x2, 4, lower.tail = FALSE)
#comparing with PC and NPC
cor(resultsPC$pvaluesPC[, 'Fisher'], fisherPvalue)
cor(resultsNPC$pvaluesNPC[, 'Fisher'], fisherPvalue)
#computing FDR from scratch
fisherQvalue <- p.adjust(fisherPvalue, method = 'fdr')
#comparing with PC and NPC
cor(resultsPC$qvaluesPC[, 'Fisher'], fisherQvalue)
cor(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
plot(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
#### Multi-class outcome, two datasets ####
#changing phenotype
phenotypeData <- as.data.frame(phenotypeData)
phenotypeData[, 'outcome'] <- rep(letters[1:3], 10)
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(results)
#### Survival outcome, two datasets ####
#changing phenotype
phenotypeData[, 'outcome'] <- Surv(time = runif(30),
event = sample(0:1, size = 30, replace = TRUE))
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(results)
#### Binary outcome, three datasets ####
#changing phenotype
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#additional dataset
dataset3 <- matrix(rnorm(100*30), 100, 30)
rownames(dataset3) <- paste('m', 1:100, sep = '_')
colnames(dataset3) <- paste('sample', 1:30, sep = '_')
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2), rownames(dataset3))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2', 'dataset3')
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = FALSE, numPerms = numPerms, numCores = numCores)
print(results)
#### Binary outcome, three datasets, all combinations ####
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
print(results)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),returnPermPvalues = TRUE
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),returnPermPvalues = TRUE,
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = FALSE, numPerms = numPerms, numCores = numCores)
print(results)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
source('D:/Dropbox (Personal)/inprogress/TwoPagesBionformatics/STATegRa/tests/tmp/testOmicsNPC_update.R')
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
print(results)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),returnPermPvalues = TRUE,
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
dim(results$pvaluesPerm)
source('D:/Dropbox (Personal)/inprogress/TwoPagesBionformatics/STATegRa/tests/tmp/testOmicsNPC_update.R')
