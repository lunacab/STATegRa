}
#does phenotypeData contain the correct sample names?
if(length(intersect(rownames(phenotypeData), allSampleNames)) == 0){
stop('phenotypeData rows must be the named after the samples')
}
#ensuring phenotypeData is a data frame
phenotypeData <- as.data.frame(phenotypeData)
#extracting each single design
designs <- vector('list', length(dataInput));
names(designs) <- names(dataInput);
for(i in 1:length(dataInput)){
designs[[i]] <- phenotypeData[colnames(dataInput[[i]]), ]
}
}
# functions to analyze data
if(class(dataTypes) == 'character'){
functionsAnalyzingData <- vector('list', length(dataTypes));
for(i in 1:length(dataTypes)){
if(dataTypes[i] == 'continuous'){
functionsAnalyzingData[[i]] <- computeAssocContinuousData;
}else{
functionsAnalyzingData[[i]] <- computeAssocCountData;
}
}
}else{
functionsAnalyzingData <- dataTypes;
}
# function to permute data
if(is.null(functionGeneratingIndex)){
functionGeneratingIndex <- generate_iid_data_index
}
datasetsNames <- names(dataMatrices);
numDataMatrices <- length(dataMatrices)
numCombMethods <- length(combMethods);
parallelAvailable <- FALSE;
system.time(tmp <- computeAssociation(dataMatrices = dataMatrices, designs = designs, dataMapping = dataMapping, functionsAnalyzingData = functionsAnalyzingData, outcomeName = outcomeName))
stats0 <- tmp$stats
results0 <- tmp$results
measurements <- dimnames(stats0)[[1]];
numMeasurements <- length(measurements);
restrictedDataMatrices <- dataMatrices
for(i in 1:length(dataMatrices)){
restrictedDataMatrices[[i]] <- dataMatrices[[i]][unique(dataMapping[ , i]), , drop = FALSE]
}
executePermutation <- function(...){
# permute designs
permDesigns <- permutingData(designs = designs, functionGeneratingIndex = functionGeneratingIndex, outcomeName = outcomeName, ...)
#permDesigns <- permutingData(designs = designs, functionGeneratingIndex = functionGeneratingIndex, outcomeName = outcomeName)
# recompute pvalues
tempRes <- computeAssociation(restrictedDataMatrices, designs = permDesigns, dataMapping = dataMapping, functionsAnalyzingData = functionsAnalyzingData, outcomeName = outcomeName, ...)
#tempRes <- computeAssociation(restrictedDataMatrices, designs = permDesigns, dataMapping = dataMapping, functionsAnalyzingData = functionsAnalyzingData, outcomeName = outcomeName)
tempRes <- tempRes$stats
#return
return(tempRes)
}
cl <- parallel::makeCluster(numCores)
doSNOW::registerDoSNOW(cl)
statsPerm <- foreach(i = 1:numPerms, .packages = c('limma', 'survival'),
.export = c('combiningPvalues', 'permutingData', 'computeAssociation')) %dopar% {
#tryCatch({executePermutation(...)},
tryCatch({executePermutation()},
error = function(e){
tempRes <- matrix(NA, dim(dataMapping)[1], dim(dataMapping)[2] - 1);
rownames(tempRes) <- rownames(dataMapping);
colnames(tempRes) <- colnames(dataMapping)[1:(dim(dataMapping)[2] - 1)];
return(tempRes)
}
)
}
parallel::stopCluster(cl)
parallelAvailable <- TRUE;
statsPerm <- c(list(stats0), statsPerm)
statsPerm <- array(unlist(statsPerm),
dim = c(nrow(statsPerm[[1]]), ncol(statsPerm[[1]]), length(statsPerm)),
dimnames = list(rownames(statsPerm[[1]]),
colnames(statsPerm[[1]]),
1:length(statsPerm)))
statsPerm
pvaluesPerm <- statisticsToPvalues(statsPerm)
pvaluesPerm <- aperm(pvaluesPerm, c(2, 3, 1)) # magic numbers!
combinations <- list();
for(i in 2:numDataMatrices){
combinations <- c(combinations, combn(1:numDataMatrices, i, simplify = FALSE));
}
numCombinations <- length(combinations);
dataMappings <- vector('list', numCombinations);
pvaluesNPC <- vector('list', numCombinations);
fdrNPC <- vector('list', numCombinations);
for(j in 1:numCombinations){
#initializing
statsNPC <- array(dim = c(numMeasurements, numCombMethods, numPerms + 1),
dimnames = list(measurements, combMethods, dimnames(pvaluesPerm)[[3]]));
#is parallel available?
if(parallelAvailable){
#creating the cluster
cl <- parallel::makeCluster(numCores)
#registering the cluster
doSNOW::registerDoSNOW(cl)
#combining the pvalues. Here we choose which data matrice to combine
for(i in 1:numCombMethods){
statsNPC[ , i, ] <- foreach(k = 1:dim(pvaluesPerm)[3], .combine = 'cbind',
.export = c('combiningPvalues', 'permutingData', 'computeAssociation')) %dopar% {
combiningPvalues(as.matrix(pvaluesPerm[ , combinations[[j]], k]), method = combMethods[i], dataWeights = dataWeights);
}
}
#closing the cluster
parallel::stopCluster(cl)
}else{
#combining the pvalues. Here we choose which data matrice to combine
for(i in 1:numCombMethods){
statsNPC[ , i, ] <-  apply(pvaluesPerm[ , combinations[[j]], ], 3, combiningPvalues, method = combMethods[i], dataWeights = dataWeights);
}
}
#let's ensure that all statistics are larger than 0
#this does not affect the computation of the pvalues
finiteStats <- !is.infinite(statsNPC);
minStats <- min(statsNPC[finiteStats], na.rm = TRUE);
maxStats <- max(statsNPC[finiteStats], na.rm = TRUE);
statsNPC[!finiteStats & sign(statsNPC) < 0] <- minStats - 1;
statsNPC[!finiteStats & sign(statsNPC) > 0] <- maxStats + 1;
minStats <- min(statsNPC, na.rm = TRUE);
statsNPC <- statsNPC - min(statsNPC) + 1
#computing the NPC p-values
pvaluesNPCTemp <- statisticsToPvalues(statsNPC);
pvaluesNPCTemp <- aperm(pvaluesNPCTemp, c(2, 3, 1)) # magic numbers!
#creating the data mapping for the combination at hand
dataMappingTmp <- dataMapping[, combinations[[j]]];
toKeep <- !duplicated(dataMappingTmp) & !apply(dataMappingTmp, 1, function(x){all(is.na(x))})
# dataMappingTmp <- cbind(dataMappingTmp[toKeep, ], dataMapping[toKeep, ncol(dataMapping)]) #adding the reference
# rownames(dataMappingTmp) <- apply(dataMappingTmp, 1, function(x){paste(x, collapse = ':')});
dataMappingTmp <- dataMappingTmp[toKeep, ]
#keeping only the relevant pvalues
if(!returnPermPvalues){
pvaluesNPC[[j]] <- matrix(pvaluesNPCTemp[toKeep, , 1],
nrow = sum(toKeep),
ncol = numCombMethods,
dimnames = list(dimnames(pvaluesNPCTemp)[[1]][toKeep], dimnames(pvaluesNPCTemp)[[2]]))
rownames(pvaluesNPC[[j]]) <- rownames(dataMappingTmp);
}else{
pvaluesNPC[[j]] <- pvaluesNPCTemp[toKeep, , ];
dimnames(pvaluesNPC[[j]])[[1]] <- rownames(dataMappingTmp);
}
#storing and naming the results
dataMappings[[j]] <- dataMappingTmp;
names(pvaluesNPC)[j] <- paste(datasetsNames[combinations[[j]]], collapse = '_');
names(dataMappings)[j] <- names(pvaluesNPC)[j];
fdrNPC[[j]] <- FDR_calculation(statsNPC)
names(fdrNPC)[j] <- names(pvaluesNPC)[j];
#adding data mapping to pvaluesNPC and fdrNPC
pvaluesNPC[[j]] <- cbind(dataMappings[[j]], pvaluesNPC[[j]])
rownames(pvaluesNPC[[j]]) <- NULL;
fdrNPC[[j]] <- cbind(dataMappings[[j]], fdrNPC[[j]])
rownames(fdrNPC[[j]]) <- NULL;
}
j =1
statsNPC <- array(dim = c(numMeasurements, numCombMethods, numPerms + 1),
dimnames = list(measurements, combMethods, dimnames(pvaluesPerm)[[3]]));
cl <- parallel::makeCluster(numCores)
doSNOW::registerDoSNOW(cl)
for(i in 1:numCombMethods){
statsNPC[ , i, ] <- foreach(k = 1:dim(pvaluesPerm)[3], .combine = 'cbind',
.export = c('combiningPvalues', 'permutingData', 'computeAssociation')) %dopar% {
combiningPvalues(as.matrix(pvaluesPerm[ , combinations[[j]], k]), method = combMethods[i], dataWeights = dataWeights);
}
}
parallel::stopCluster(cl)
statsNPC
finiteStats <- !is.infinite(statsNPC);
minStats <- min(statsNPC[finiteStats], na.rm = TRUE);
maxStats <- max(statsNPC[finiteStats], na.rm = TRUE);
statsNPC[!finiteStats & sign(statsNPC) < 0] <- minStats - 1;
statsNPC[!finiteStats & sign(statsNPC) > 0] <- maxStats + 1;
minStats <- min(statsNPC, na.rm = TRUE);
statsNPC <- statsNPC - min(statsNPC) + 1
pvaluesNPCTemp <- statisticsToPvalues(statsNPC);
pvaluesNPCTemp <- aperm(pvaluesNPCTemp, c(2, 3, 1)) # magic numbers!
dataMappingTmp <- dataMapping[, combinations[[j]]];
toKeep <- !duplicated(dataMappingTmp) & !apply(dataMappingTmp, 1, function(x){all(is.na(x))})
dataMappingTmp <- dataMappingTmp[toKeep, ]
if(!returnPermPvalues){
pvaluesNPC[[j]] <- matrix(pvaluesNPCTemp[toKeep, , 1],
nrow = sum(toKeep),
ncol = numCombMethods,
dimnames = list(dimnames(pvaluesNPCTemp)[[1]][toKeep], dimnames(pvaluesNPCTemp)[[2]]))
rownames(pvaluesNPC[[j]]) <- rownames(dataMappingTmp);
}else{
pvaluesNPC[[j]] <- pvaluesNPCTemp[toKeep, , ];
dimnames(pvaluesNPC[[j]])[[1]] <- rownames(dataMappingTmp);
}
dataMappings[[j]] <- dataMappingTmp;
names(pvaluesNPC)[j] <- paste(datasetsNames[combinations[[j]]], collapse = '_');
names(dataMappings)[j] <- names(pvaluesNPC)[j];
fdrNPC[[j]] <- FDR_calculation(statsNPC)
class(statsNPC)
statsNPC
dim(statsNPC)
dimnames(statsNPC)
fdrNPC[[j]] <- apply(statsNPC, 2, FDR_calculation)
fdrNPC[[j]]
names(fdrNPC)[j] <- names(pvaluesNPC)[j];
pvaluesNPC[[j]] <- cbind(dataMappings[[j]], pvaluesNPC[[j]])
rownames(pvaluesNPC[[j]]) <- NULL;
fdrNPC[[j]] <- cbind(dataMappings[[j]], fdrNPC[[j]])
rownames(fdrNPC[[j]]) <- NULL;
#### Script for testing the omicsNPC function ####
#### Set up ####
#memory, library and sourcing
rm(list = ls())
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsPC_internal.R')
library(foreach)
library(data.table)
#control panel
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 3;
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#one data matrix is actually differentially expressed
dataset1[ , 16:20] <- dataset1[ , 16:20] + 3 * matrix(runif(100 * 5), 100, 5)
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
#omicsNPC
resultsNPC <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(resultsNPC)
#omicsPC
resultsPC <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2),
dataMapping = dataMapping, phenotypeData = phenotypeData)
print(resultsPC)
#computing fisher p-values from scratch
p1 <- resultsPC$dataset1[dataMapping$dataset1, 'P.Value']
p2 <- resultsPC$dataset2[dataMapping$dataset2, 'P.Value']
x2 <- -2 * (log(p1) + log(p2))
fisherPvalue <- pchisq(x2, 4, lower.tail = FALSE)
#comparing with PC and NPC
cor(resultsPC$pvaluesPC[, 'Fisher'], fisherPvalue)
cor(resultsNPC$pvaluesNPC[, 'Fisher'], fisherPvalue)
#computing FDR from scratch
fisherQvalue <- p.adjust(fisherPvalue, method = 'fdr')
#comparing with PC and NPC
cor(resultsPC$qvaluesPC[, 'Fisher'], fisherQvalue)
cor(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
plot(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
#### Multi-class outcome, two datasets ####
#changing phenotype
phenotypeData <- as.data.frame(phenotypeData)
phenotypeData[, 'outcome'] <- rep(letters[1:3], 10)
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(results)
#### Survival outcome, two datasets ####
#changing phenotype
phenotypeData[, 'outcome'] <- Surv(time = runif(30),
event = sample(0:1, size = 30, replace = TRUE))
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(results)
#### Binary outcome, three datasets ####
#changing phenotype
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#additional dataset
dataset3 <- matrix(rnorm(100*30), 100, 30)
rownames(dataset3) <- paste('m', 1:100, sep = '_')
colnames(dataset3) <- paste('sample', 1:30, sep = '_')
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2), rownames(dataset3))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2', 'dataset3')
#omicsNPC
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = FALSE, numPerms = numPerms, numCores = numCores)
print(results)
#### Binary outcome, three datasets, all combinations ####
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
print(results)
print(results)
rm(list = ls())
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsPC_internal.R')
library(foreach)
library(data.table)
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 3;
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataset1[ , 16:20] <- dataset1[ , 16:20] + 3 * matrix(runif(100 * 5), 100, 5)
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
resultsNPC <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(resultsNPC)
resultsPC <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2),
dataMapping = dataMapping, phenotypeData = phenotypeData)
print(resultsPC)
p1 <- resultsPC$dataset1[dataMapping$dataset1, 'P.Value']
p2 <- resultsPC$dataset2[dataMapping$dataset2, 'P.Value']
x2 <- -2 * (log(p1) + log(p2))
fisherPvalue <- pchisq(x2, 4, lower.tail = FALSE)
cor(resultsPC$pvaluesPC[, 'Fisher'], fisherPvalue)
cor(resultsNPC$pvaluesNPC[, 'Fisher'], fisherPvalue)
fisherQvalue <- p.adjust(fisherPvalue, method = 'fdr')
cor(resultsPC$qvaluesPC[, 'Fisher'], fisherQvalue)
cor(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
plot(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
cor(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
plot(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
cor(resultsPC$qvaluesPC[, 'Fisher'], fisherQvalue)
cor(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
plot(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
fisherQvalue <- p.adjust(fisherPvalue, method = 'fdr')
#### Script for testing the omicsNPC function ####
#### Set up ####
#memory, library and sourcing
rm(list = ls())
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsPC_internal.R')
library(foreach)
library(data.table)
#control panel
set.seed(12345)
combMethods <- c('Fisher', 'Liptak', 'Tippett');
numPerms <- 10;
numCores <- 3;
#### Binary outcome, two datasets ####
#creating the data matrices
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
#creating the phenotype data
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
#one data matrix is actually differentially expressed
dataset1[ , 16:20] <- dataset1[ , 16:20] + 3 * matrix(runif(100 * 5), 100, 5)
#data mapping
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
#omicsNPC
resultsNPC <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(resultsNPC)
#omicsPC
resultsPC <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2),
dataMapping = dataMapping, phenotypeData = phenotypeData)
print(resultsPC)
#computing fisher p-values from scratch
p1 <- resultsPC$dataset1[dataMapping$dataset1, 'P.Value']
p2 <- resultsPC$dataset2[dataMapping$dataset2, 'P.Value']
x2 <- -2 * (log(p1) + log(p2))
fisherPvalue <- pchisq(x2, 4, lower.tail = FALSE)
#comparing with PC and NPC
cor(resultsPC$pvaluesPC[, 'Fisher'], fisherPvalue)
cor(resultsNPC$pvaluesNPC[, 'Fisher'], fisherPvalue)
#computing FDR from scratch
fisherQvalue <- p.adjust(fisherPvalue, method = 'fdr')
#comparing with PC and NPC
cor(resultsPC$qvaluesPC[, 'Fisher'], fisherQvalue)
cor(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
plot(resultsNPC$qvaluesNPC[, 'Fisher'], fisherQvalue)
phenotypeData <- as.data.frame(phenotypeData)
phenotypeData[, 'outcome'] <- rep(letters[1:3], 10)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(results)
phenotypeData[, 'outcome'] <- Surv(time = runif(30),
event = sample(0:1, size = 30, replace = TRUE))
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData, numPerms = numPerms, numCores = numCores)
print(results)
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataset3 <- matrix(rnorm(100*30), 100, 30)
rownames(dataset3) <- paste('m', 1:100, sep = '_')
colnames(dataset3) <- paste('sample', 1:30, sep = '_')
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2), rownames(dataset3))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2', 'dataset3')
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = FALSE, numPerms = numPerms, numCores = numCores)
print(results)
results <- omicsNPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE, numPerms = numPerms, numCores = numCores)
print(results)
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_internal.R')
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
set.seed(12345)
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
print(results)
phenotypeData <- as.data.frame(phenotypeData)
phenotypeData[, 'outcome'] <- rep(letters[1:3], 10)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
rm(list = ls())
source('../../R/STATegRa_omicsPC_internal.R')
source('../../R/STATegRa_omicsPC.R')
source('../../R/STATegRa_omicsNPC_internal.R')
source('../../R/STATegRa_omicsNPC_ancillaryFunctions.R')
set.seed(12345)
dataset1 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset1) <- paste('g', 1:100, sep = '_')
colnames(dataset1) <- paste('sample', 1:20, sep = '_')
dataset2 <- matrix(rnorm(100*20), 100, 20)
rownames(dataset2) <- paste('p', 1:100, sep = '_')
colnames(dataset2) <- paste('sample', 11:30, sep = '_')
phenotypeData <- matrix(rnorm(30*3), 30, 3)
rownames(phenotypeData) <- paste('sample', 1:30, sep = '_')
colnames(phenotypeData) <- c('cov1', 'cov2', 'outcome')
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2')
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
phenotypeData <- as.data.frame(phenotypeData)
phenotypeData[, 'outcome'] <- rep(letters[1:3], 10)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
phenotypeData[, 'outcome'] <- Surv(time = runif(30),
event = sample(0:1, size = 30, replace = TRUE))
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2), dataMapping = dataMapping,
phenotypeData = phenotypeData)
print(results)
phenotypeData[, 'outcome'] <- c(rep(1, 15), rep(0, 15))
dataset3 <- matrix(rnorm(100*30), 100, 30)
rownames(dataset3) <- paste('m', 1:100, sep = '_')
colnames(dataset3) <- paste('sample', 1:30, sep = '_')
dataMapping <- expand.grid(rownames(dataset1), rownames(dataset2), rownames(dataset3))
dataMapping <- dataMapping[sample(1:nrow(dataMapping), 100), ]
colnames(dataMapping) <- c('dataset1', 'dataset2', 'dataset3')
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData)
print(results)
results <- omicsPC(dataInput = list(dataset1=dataset1, dataset2=dataset2, dataset3=dataset3),
dataMapping = dataMapping, phenotypeData = phenotypeData,
allCombinations = TRUE)
print(results)
